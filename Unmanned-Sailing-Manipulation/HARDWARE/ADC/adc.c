#include <stm32f10x_lib.h>
#include "adc.h"
#include "delay.h"

u16  ADC_FIFO[2][11]; //磁力计滤波
 
		   
//初始化ADC
//这里我们仅以规则通道为例
//我们默认将开启通道0~3																	   
void  Adc_Init(void)
{    
	//先初始化IO口
 	RCC->APB2ENR|=1<<2;    //使能PORTA口时钟 
	GPIOA->CRL&=0XFFFFFF00;//PA0 1   anolog输入	 ///////////////////////////
	//通道10/11设置			 
	RCC->APB2ENR|=1<<9;    //ADC1时钟使能	  
	RCC->APB2RSTR|=1<<9;   //ADC1复位
	RCC->APB2RSTR&=~(1<<9);//复位结束	    
	RCC->CFGR&=~(3<<14);   //分频因子清零	
	//SYSCLK/DIV2=12M ADC时钟设置为12M,ADC最大时钟不能超过14M!
	//否则将导致ADC准确度下降! 
	RCC->CFGR|=2<<14;      	//时钟配置寄存器(RCC_CFGR) 
							//10：PCLK2 6分频后作为ADC 时钟	   72/6=12Mz
	ADC1->CR1&=0XF0FFFF;   //工作模式清零
	ADC1->CR1|=0<<16;      //独立工作模式  
	ADC1->CR1&=~(1<<8);    //非扫描模式	  
	ADC1->CR2&=~(1<<1);    //单次转换模式
	ADC1->CR2&=~(7<<17);	   
	ADC1->CR2|=7<<17;	   //软件控制转换  
	ADC1->CR2|=1<<20;      //使用用外部触发(SWSTART)!!!	必须使用一个事件来触发
	ADC1->CR2&=~(1<<11);   //右对齐	 
	ADC1->SQR1&=~(0XF<<20);
	ADC1->SQR1&=0<<20;     //1个转换在规则序列中 也就是只转换规则序列1 			   
	//设置通道0~3的采样时间
	ADC1->SMPR2&=0XFFFFF000;//通道0,1,2,3采样时间清空	  
//	ADC1->SMPR2|=7<<9;      //通道3  239.5周期,提高采样时间可以提高精确度	 
//	ADC1->SMPR2|=7<<6;      //通道2  239.5周期,提高采样时间可以提高精确度	 
	ADC1->SMPR2|=7<<3;      //通道1  239.5周期,提高采样时间可以提高精确度	 
	ADC1->SMPR2|=7<<0;      //通道0  239.5周期,提高采样时间可以提高精确度	 

	ADC1->CR2|=1<<0;	    //开启AD转换器	 
	ADC1->CR2|=1<<3;        //使能复位校准  
	while(ADC1->CR2&1<<3);  //等待校准结束 			 
    //该位由软件设置并由硬件清除。在校准寄存器被初始化后该位将被清除。 		 
	ADC1->CR2|=1<<2;        //开启AD校准	   
	while(ADC1->CR2&1<<2);  //等待校准结束
	//该位由软件设置以开始校准，并在校准结束时由硬件清除  
	ADC_FIFO_Init();
}				  
//获得ADC值
//ch:通道值 0~3
u16 Get_Adc(u8 ch)   
{
	u8 ad_times;
	u16 adc_result;
	//设置转换序列	  		 
	ADC1->SQR3&=0XFFFFFFE0;//规则序列1 通道ch
	ADC1->SQR3|=ch;		  			    
	for(ad_times=8;ad_times>0;ad_times--)
	{
		ADC1->CR2|=1<<22;       //启动规则转换通道 
		while(!(ADC1->SR&1<<1));//等待转换结束	 	   
		adc_result += ADC1->DR;
	}
	return (u16)(adc_result/8.0);		//返回adc值	
}
/******************************************************************************
以下函数是参考IMU_HMC5883L的数据处理方法：“循环队列求平均值”
20130607 彭向岐
*******************************************************************************/

//获得ADC值
//ch:通道值 0~3
u16 AdcGetChValue(u8 ch)   
{
	//设置转换序列	  		 
	ADC1->SQR3&=0XFFFFFFE0;//规则序列1 通道ch
	ADC1->SQR3|=ch;		  			    
	ADC1->CR2|=1<<22;       //启动规则转换通道 
	while(!(ADC1->SR&1<<1));//等待转换结束	 	   
	return ADC1->DR;		//返回adc值	
}
/**************************实现函数********************************************
*函数原型:	   void ADC_FIFO_Init(void)
*功　　能:	   连续读取50次数据，以初始化FIFO数组
输入参数：  无
输出参数：  无
*******************************************************************************/
void ADC_FIFO_Init(void)
{
	u16 temp[2];
	u8 i;
	for(i=0;i<50;i++)
	{
		ADC_getValues(&temp[0],&temp[1]);
		delay_us(200);  //延时再读取数据
	}
}
/**************************实现函数********************************************
*函数原型:	   void  ADC_newValues(u16 x,u16 y)
*功　　能:	   更新一组数据到FIFO数组
输入参数：  ADC两通道采集的数据
输出参数：  无
*******************************************************************************/
void  ADC_newValues(u16 x,u16 y)
{
	unsigned char i ;
	u32 sum=0;

	for(i=1;i<10;i++)
	{
		ADC_FIFO[0][i-1]=ADC_FIFO[0][i];
		ADC_FIFO[1][i-1]=ADC_FIFO[1][i];
	}

	ADC_FIFO[0][9]=x;  //将最新的一个数据装入数组尾
	ADC_FIFO[1][9]=y;  //将最新的一个数据装入数组尾

	sum=0;
	for(i=0;i<10;i++)
	{	//取数组内的值进行求和再取平均
   		sum+=ADC_FIFO[0][i];
	}
	ADC_FIFO[0][10]=sum/10;	//将平均值更新

	sum=0;
	for(i=0;i<10;i++)
	{
   		sum+=ADC_FIFO[1][i];
	}
	ADC_FIFO[1][10]=sum/10;

} //ADC_newValues

/**************************实现函数********************************************
*函数原型:	  void ADC_getValues(u16 *x,u16 *y) 

*功　　能:	   获得ADC两个通道的滤波之后的数值
输入参数：   	
输出参数：  无
*******************************************************************************/
void ADC_getValues(u16 *x,u16 *y) 
{
   ADC_newValues(AdcGetChValue(FAN_DIR_CH),AdcGetChValue(WIND_DIR_CH));
   *x = ADC_FIFO[0][10];
   *y = ADC_FIFO[1][10];
}

























